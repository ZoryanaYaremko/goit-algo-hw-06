import networkx as nx
import heapq

# Використовуємо граф, створений раніше
G = nx.Graph()

# Додавання станцій метро як вершин графа
stations = [
    "Святошин", "Нивки", "Політехнічний інститут", "Театральна", "Хрещатик", "Арсенальна", "Дарниця", 
    "Лісова", "Академмістечко", "Житомирська", "Берестейська", "Вокзальна", "Університет", 
    "Золоті ворота", "Палац спорту", "Кловська", "Печерська", "Дружби народів", "Видубичі", 
    "Славутич", "Осокорки", "Позняки", "Харківська", "Вирлиця", "Бориспільська", "Червоний хутір",
    "Лук'янівська", "Дорогожичі", "Сирець", "Либідська", "Героїв Дніпра", "Мінська", 
    "Оболонь", "Петрівка", "Тараса Шевченка", "Контрактова площа", "Поштова площа", 
    "Майдан Незалежності"
]

# Додавання ребер графа з вагами
# Ваги можуть відповідати, наприклад, часу у хвилинах між станціями
edges = [
    ("Академмістечко", "Житомирська", 5), ("Житомирська", "Святошин", 4), 
    ("Святошин", "Нивки", 3), ("Нивки", "Берестейська", 2),
    ("Берестейська", "Політехнічний інститут", 4), ("Політехнічний інститут", "Вокзальна", 3),
    ("Вокзальна", "Університет", 3), ("Університет", "Театральна", 2),
    ("Театральна", "Хрещатик", 1), ("Хрещатик", "Арсенальна", 2), 
    ("Арсенальна", "Дарниця", 7), ("Дарниця", "Лісова", 5),
    ("Майдан Незалежності", "Хрещатик", 1), ("Майдан Незалежності", "Поштова площа", 2),
    ("Поштова площа", "Контрактова площа", 2), ("Контрактова площа", "Тараса Шевченка", 3),
    ("Тараса Шевченка", "Петрівка", 2), ("Петрівка", "Оболонь", 4),
    ("Оболонь", "Мінська", 3), ("Мінська", "Героїв Дніпра", 3),
    ("Золоті ворота", "Театральна", 1), ("Золоті ворота", "Лук'янівська", 5),
    ("Лук'янівська", "Дорогожичі", 3), ("Дорогожичі", "Сирець", 2),
    ("Золоті ворота", "Університет", 1), ("Золоті ворота", "Палац спорту", 2),
    ("Палац спорту", "Кловська", 2), ("Кловська", "Печерська", 2),
    ("Печерська", "Дружби народів", 2), ("Дружби народів", "Видубичі", 3),
    ("Видубичі", "Славутич", 5), ("Славутич", "Осокорки", 3),
    ("Осокорки", "Позняки", 2), ("Позняки", "Харківська", 2),
    ("Харківська", "Вирлиця", 3), ("Вирлиця", "Бориспільська", 3),
    ("Бориспільська", "Червоний хутір", 4), ("Палац спорту", "Либідська", 2)
]

# Додавання вершин і ребер до графу
G.add_weighted_edges_from(edges)

# Функція для знаходження найкоротшого шляху з використанням алгоритму Дейкстри
def dijkstra(graph, start):
    # Ініціалізація відстаней до всіх вершин як нескінченних
    distances = {node: float('inf') for node in graph.nodes}
    distances[start] = 0

    # Пріоритетна черга для збереження вершин для обробки
    priority_queue = [(0, start)]
    
    while priority_queue:
        current_distance, current_node = heapq.heappop(priority_queue)
        
        # Якщо поточна відстань більше, ніж відома найкоротша, пропускаємо
        if current_distance > distances[current_node]:
            continue

        # Оновлення відстаней до сусідів
        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight['weight']
            
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))
    
    return distances

# Знаходження найкоротших шляхів з використанням алгоритму Дейкстри для кожної вершини
all_shortest_paths = {}
for station in stations:
    all_shortest_paths[station] = dijkstra(G, station)

# Виведення найкоротших шляхів від станції "Академмістечко"
print("Найкоротші шляхи від станції Академмістечко:")
for station, distance in all_shortest_paths["Академмістечко"].items():
    print(f"Відстань до {station}: {distance} хвилин")
